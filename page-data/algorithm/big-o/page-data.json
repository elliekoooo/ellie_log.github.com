{"componentChunkName":"component---src-pages-index-tsx","path":"/algorithm/big-o/","result":{"data":{"markdownRemark":{"id":"436bb1e4-4d4a-5ee1-871d-76286c6469b4","rawMarkdownBody":"\n# Big O\n\n_Reference; Cracking The Coding Interview_\n\n\n##### Time Complexity\n* What the concept of asymptotic runtime, Big O time.\n\t\n    * Electronic Transfer: The size of file is going up, The time to transfer file is going up. O(s).\n    * Airplane Transfer: THe size of file is going up, The time is constant. O(1).\n    \n-  linear will at some point surpass constant\n\n* Best case / worst case / Expected case\n\n> e.g. quick sort?\n> \n> best case: when if all elements are equal, the quick sort will traverse the array once. <O(N)>\n> worst case: when if the pivot is repeatedly the biggest element in the array? => Our recursion doesn't devide the array in half, and recurse on each half <O(N^2)>\n> expected case: Sometimes the pivot will be very low or very high, but it won't always happen. <O(NlogN)>\n\n##### Space complexity\n\n* the amount of memory or space required by algorithm.\n\t\n    * array size of n -> O(n) space.\t\n    * two-dimensinal array of size nxn -> O(n*) space.\n    \n** stack space in recursive calls counts\n \n```java\n\t\n    int sum(int n) {\n    \t\n        if(n <= 0)\n        \treturn;\n   \t\t\n        return n + sum(n-1);\n   }    \n```\n\n sum(4) -> sum(3) -> sum(2) -> sum(1)\n - each of there calls is added to the call stack and takes up actual memory.\n\n** because you have n calls, that doesn't mean it takes O(n) space.\n\n```java\n\nint pairSumSequenceFirst() {\n\tint sum = 0;\n    \n    for(int i = 0; i < n; i++ {\n    \tsum += pairSum(i, i+1);   \n    }\n    \n    return sum;\n}\n\nint pairSum(int a, int b){\n\treturn a+b;\n}\n```\n\n* Drop the constants\n* Drop the Non-Dominant Terms\n* Multi-part Algorithms: Add vs Mutiply.\n\n> O(A+B)\n\n>  ```java\n>    for(int a: arrA) {\n>        print(a)\n>    };\n>\n>    for(int b: arrB) {\n>        print(b)\n>    };\n>    ```\n\n> O(A*B)\n\n> ```java\n>\tfor(int a: arrA){\n>\t\tfor(int b: arrB{\n>\t\t\tpinrt(a + \",\" + b);\n>\t\t}\n>\t}\t\n> ```\n\n* Amortized Time\n* Log N Runtimes\n\t- When you see a problem where the number of elements in the problem space gets halved each time, that will likely be a O(logN) runtime.\n    \n* Recursive Runtimes \n\n\n    \n","frontmatter":{"category":"algorithm"}}},"pageContext":{"id":"436bb1e4-4d4a-5ee1-871d-76286c6469b4","slug":"/algorithm/big-o/","category":"algorithm"}},"staticQueryHashes":["4194050436"],"slicesMap":{}}